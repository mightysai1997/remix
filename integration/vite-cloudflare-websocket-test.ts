import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import dedent from "dedent";

import type { Files } from "./helpers/vite.js";
import { test, viteConfig } from "./helpers/vite.js";

const files: Files = async ({ port }) => ({
  "package.json": JSON.stringify(
    {
      private: true,
      sideEffects: false,
      type: "module",
      scripts: {
        dev: "remix vite:dev",
        "dev:service": "wrangler dev --config wrangler.service.toml",
        build: "remix vite:build",
        start: "wrangler pages dev ./build/client",
        deploy: "wrangler pages deploy ./build/client",
        typecheck: "tsc",
      },
      dependencies: {
        "@remix-run/cloudflare": "*",
        "@remix-run/cloudflare-pages": "*",
        "@remix-run/react": "*",
        isbot: "^4.1.0",
        miniflare: "^3.20231030.4",
        react: "^18.2.0",
        "react-dom": "^18.2.0",
      },
      devDependencies: {
        "@cloudflare/workers-types": "^4.20230518.0",
        "@remix-run/dev": "*",
        "@types/react": "^18.2.20",
        "@types/react-dom": "^18.2.7",
        "node-fetch": "^3.3.2",
        typescript: "^5.1.6",
        vite: "^5.1.0",
        "vite-tsconfig-paths": "^4.2.1",
        wrangler: "^3.28.2",
      },
      engines: {
        node: ">=18.0.0",
      },
    },
    null,
    2
  ),
  "vite.config.ts": dedent`
    import {
      vitePlugin as remix,
      cloudflareDevProxyVitePlugin as remixCloudflareDevProxy,
    } from "@remix-run/dev";

    export default {
      ${await viteConfig.server({ port })}
      plugins: [
        remixCloudflareDevProxy(),
        remix(),
      ],
    }
  `,
  "load-context.ts": `
    import { type AppLoadContext } from "@remix-run/cloudflare";
    import { type PlatformProxy } from "wrangler";

    type Env = {
      EchoDo: DurableObjectNamespace;
    }
    type Cloudflare = Omit<PlatformProxy<Env>, 'dispose'>;

    declare module "@remix-run/cloudflare" {
      interface AppLoadContext {
        cloudflare: Cloudflare;
      }
    }
  `,
  "functions/[[page]].ts": `
    import { createPagesFunctionHandler } from "@remix-run/cloudflare-pages";

    // @ts-ignore - the server build file is generated by \`remix vite:build\`
    import * as build from "../build/server";
    import { getLoadContext } from "../load-context";

    export const onRequest = createPagesFunctionHandler({
      build,
      getLoadContext,
    });
  `,
  "wrangler.toml": `
    [[durable_objects.bindings]]
    name = "EchoDo"
    class_name = "EchoDo"
    script_name = "echo"

    [[migrations]]
    tag = "v1"
    new_classes = ["EchoDo"]
  `,
  "service.ts": `
    interface Env {
      EchoDo: DurableObjectNamespace;
    }
    
    /**
     * no-op fetch handler as we only use the durable object from this service.
     */
    export default {
      async fetch(_request: Request, _env: Env, _ctx: ExecutionContext) {
        return new Response(null, { status: 200 });
      },
    };

    let textDecoder = new TextDecoder("utf-8");
    
    export class EchoDo {
      #state: DurableObjectState;
    
      constructor(state: DurableObjectState, _env: Env) {
        this.#state = state;
      }
    
      async fetch(request: Request) {
        let url = new URL(request.url);
    
        switch (url.pathname) {
          case "/join": {
            let client = this.#join();
            return new Response(null, { status: 101, webSocket: client });
          }
          case "/broadcast": {
            break;
          }
          default: {
            return new Response(null, { status: 404 });
          }
        }
      }
    
      #join() {
        let { 0: client, 1: server } = new WebSocketPair();
        this.#state.acceptWebSocket(server);
        return client;
      }
    
      webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {
        if (message instanceof ArrayBuffer) {
          message = textDecoder.decode(message);
        }
        ws.send(message);
      }
    }  
  `,
  "wrangler.service.toml": `
    name = "echo"
    main = "service.ts"
    first_party_worker = true
  
    [[durable_objects.bindings]]
    name = "EchoDo"
    class_name = "EchoDo"

    [[migrations]]
    tag = "v1"
    new_classes = ["EchoDo"]
  `,
  "app/routes/_index.tsx": `
    import * as React from "react";

    export default function Component() {
      let socket = React.useRef<WebSocket>();
      let [messages, setMessages] = React.useState<Array<string>>([]);
    
      React.useEffect(() => {
        if (socket.current) return;
    
        let protocol = location.protocol === "http:" ? "ws:" : "wss:";
        try {
          socket.current = new WebSocket(\`\${protocol}//\${location.host}/join\`);
          socket.current.addEventListener("message", async (e) => {
            setMessages((messages) => [...messages, e.data]);
          });
        } catch (error) {
          console.error(error);
        }
      }, []);
    
      return (
        <div>
          <div>Echo</div>
          <button
            onClick={() => {
              if (!socket.current) return;
    
              socket.current.send("hello");
            }}
          >
            Hello!
          </button>
          <ul>
            {messages.map((message, index) => (
              <li data-testid={index} key={index}>{message}</li>
            ))}
          </ul>
        </div>
      );
    }
  `,
  "app/routes/join.ts": `
    import { json, type LoaderFunctionArgs } from "@remix-run/cloudflare";

    export async function loader({ context, request }: LoaderFunctionArgs) {
      let upgradeHeader = request.headers.get("upgrade");
      if (upgradeHeader !== "websocket") {
        return json({ message: "Upgrade Required" }, { status: 426 });
      }
      let { env } = context.cloudflare;
      let chatRoom = env.EchoDo.get(env.EchoDo.idFromName("echo"));
      return await chatRoom.fetch(request.url, request);
    }
  `,
});

test("vite dev", async ({ page, viteDevWaitOnWranglerService }) => {
  let { port } = await viteDevWaitOnWranglerService(
    files,
    "wrangler.service.toml"
  );
  await workflow({ page, port });
});

test("wrangler", async ({ page, wranglerPagesDevWaitOnWranglerService }) => {
  let { port } = await wranglerPagesDevWaitOnWranglerService(
    files,
    "wrangler.service.toml"
  );
  await workflow({ page, port });
});

async function workflow({ page, port }: { page: Page; port: number }) {
  await page.goto(`http://localhost:${port}/`, {
    waitUntil: "networkidle",
  });
  await page.getByRole("button").click();
  await expect(page.getByTestId("0")).toHaveText("hello");
  expect(page.errors).toEqual([]);
}
